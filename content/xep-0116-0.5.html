<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JEP-0116: Encrypted Sessions</title>
<link rel="stylesheet" type="text/css" href="jep.css">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
<meta name="DC.Title" content="Encrypted Sessions">
<meta name="DC.Creator" content="Ian Paterson">
<meta name="DC.Creator" content="Peter Saint-Andre">
<meta name="DC.Creator" content="Dave Smith">
<meta name="DC.Description" content="This JEP specifies a protocol for session-based, end-to-end encryption of XMPP communications.">
<meta name="DC.Publisher" content="Jabber Software Foundation">
<meta name="DC.Contributor" content="JEP Editor">
<meta name="DC.Date" content="2004-08-10">
<meta name="DC.Type" content="Jabber Enhancement Proposal">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="JEP-0116">
<meta name="DC.Language" content="en">
<meta name="DC.Rights" content="This Jabber Enhancement Proposal is copyright 1999 - 2005 by the Jabber Software Foundation (JSF) and is in full conformance with the JSF's Intellectual Property Rights Policy &lt;http://www.jabber.org/jsf/ipr-policy.shtml&gt;. This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at &lt;http://www.opencontent.org/openpub/&gt;).">
</head>
<body>
<h1>JEP-0116: Encrypted Sessions</h1>
<p>This JEP specifies a protocol for session-based, end-to-end encryption of XMPP communications.</p>
<p><hr></p>
<p style="color:red">WARNING: This Standards-Track JEP is Experimental. Publication as a Jabber Enhancement Proposal does not imply approval of this proposal by the Jabber Software Foundation. Implementation of the protocol described herein is encouraged in exploratory implementations, but production systems should not deploy implementations of this protocol until it advances to a status of Draft.</p>
<p><hr></p>
<h2>JEP Information</h2>
<p class="indent">
            Status: Experimental<br>
            Type: Standards Track<br>
            Number: 0116<br>
            Version: 0.5<br>
            Last Updated: 2004-08-10<br>
            JIG: Standards JIG<br>
                Approving Body: Jabber Council<br>Dependencies: XMPP Core, RFC 2104, RFC 2409, RFC 3526, RFC 3548, xml-c14n, JEP-0004, JEP-0020, JEP-0030, JEP-0068, JEP-0079, JEP-0155<br>
                Supersedes: None<br>
                Superseded By: None<br>
            Short Name: esession<br></p>
<h2>Author Information</h2>
<div class="indent">
<h3>Ian Paterson</h3>
<p class="indent">
        Email: ian.paterson@clientside.co.uk<br>
        JID: ian@zoofy.com</p>
<h3>Peter Saint-Andre</h3>
<p class="indent">
        Email: stpeter@jabber.org<br>
        JID: stpeter@jabber.org</p>
<h3>Dave Smith</h3>
<p class="indent">
        Email: dizzyd@jabber.org<br>
        JID: dizzyd@jabber.org</p>
</div>
<h2>Legal Notice</h2>
<p class="indent">This Jabber Enhancement Proposal is copyright 1999 - 2005 by the <a href="http://www.jabber.org/jsf/">Jabber Software Foundation</a> (JSF) and is in full conformance with the JSF's Intellectual Property Rights Policy &lt;<a href="http://www.jabber.org/jsf/ipr-policy.shtml">http://www.jabber.org/jsf/ipr-policy.shtml</a>&gt;. This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at &lt;<a href="http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</a>&gt;).</p>
<h2>Discussion Venue</h2>
<p class="indent">The preferred venue for discussion of this document is the Standards-JIG discussion list: &lt;<a href="http://mail.jabber.org/mailman/listinfo/standards-jig">http://mail.jabber.org/mailman/listinfo/standards-jig</a>&gt;.</p>
<p class="indent">Given that this JEP normatively references IETF technologies, discussion on the JSF-IETF list may also be appropriate (see &lt;<a href="http://mail.jabber.org/mailman/listinfo/jsf-ietf">http://mail.jabber.org/mailman/listinfo/jsf-ietf</a>&gt; for details).</p>
<h2>Relation to XMPP</h2>
<p class="indent">The Extensible Messaging and Presence Protocol (XMPP) is defined in the XMPP Core (RFC 3920) and XMPP IM (RFC 3921) specifications contributed by the Jabber Software Foundation to the Internet Standards Process, which is managed by the Internet Engineering Task Force in accordance with RFC 2026. Any protocol defined in this JEP has been developed outside the Internet Standards Process and is to be understood as an extension to XMPP rather than as an evolution, development, or modification of XMPP itself.</p>
<h2>Conformance Terms</h2>
<p class="indent">The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</p>
<p><hr></p>
<h2>Table of Contents</h2>
<div class="indent"><dl>
<dt>1.  <a href="#intro">Introduction</a>
</dt>
<dt>2.  <a href="#background">Background</a>
</dt>
<dt>3.  <a href="#terms">Terminology</a>
</dt>
<dl><dt>3.1.  <a href="#terms-personae">Dramatis Personae</a>
</dt></dl>
<dt>4.  <a href="#reqs">Requirements</a>
</dt>
<dl>
<dt>4.1.  <a href="#reqs-sec">Security Requirements</a>
</dt>
<dl>
<dt>4.1.1.  <a href="#reqs-encrypt">Confidentiality</a>
</dt>
<dt>4.1.2.  <a href="#reqs-integrity">Integrity</a>
</dt>
<dt>4.1.3.  <a href="#reqs-replay">Replay Protection</a>
</dt>
<dt>4.1.4.  <a href="#reqs-forward">Perfect Forward Secrecy</a>
</dt>
<dt>4.1.5.  <a href="#reqs-auth">Authentication</a>
</dt>
<dt>4.1.6.  <a href="#reqs-repudiate">Repudiability</a>
</dt>
</dl>
<dt>4.2.  <a href="#reqs-xmpp">Application Requirements</a>
</dt>
<dl>
<dt>4.2.1.  <a href="#reqs-generality">Generality</a>
</dt>
<dt>4.2.2.  <a href="#reqs-implement">Implementability</a>
</dt>
<dt>4.2.3.  <a href="#reqs-usable">Usability</a>
</dt>
<dt>4.2.4.  <a href="#reqs-flexible">Flexibility</a>
</dt>
<dt>4.2.5.  <a href="#reqs-usable">Interoperability</a>
</dt>
<dt>4.2.6.  <a href="#reqs-offline">Offline Sessions</a>
</dt>
</dl>
</dl>
<dt>5.  <a href="#disco">Discovering Support</a>
</dt>
<dt>6.  <a href="#init">ESession Initiation</a>
</dt>
<dl>
<dt>6.1.  <a href="#init-online">Online Diffie-Hellman Key Exchange</a>
</dt>
<dl>
<dt>6.1.1.  <a href="#init-request">Esession Request</a>
</dt>
<dt>6.1.2.  <a href="#init-prep">Diffie-Hellman Preparation (Bob)</a>
</dt>
<dt>6.1.3.  <a href="#init-response">Esession Response</a>
</dt>
<dt>6.1.4.  <a href="#init-prep2">Diffie-Hellman Preparation (Alice)</a>
</dt>
<dt>6.1.5.  <a href="#init-complete">Diffie-Hellman Completion</a>
</dt>
</dl>
<dt>6.2.  <a href="#init-offline">Offline Diffie-Hellman Key Exchange</a>
</dt>
<dl>
<dt>6.2.1.  <a href="#init-publish">Publishing Esession Options</a>
</dt>
<dt>6.2.2.  <a href="#init-offreq">Requesting Offline Esession Options</a>
</dt>
<dt>6.2.3.  <a href="#init-prep3">Diffie-Hellman Preparation (Offline)</a>
</dt>
<dt>6.2.4.  <a href="#init-start">Starting an Offline Esession</a>
</dt>
<dt>6.2.5.  <a href="#init-accept">Accepting Offline Esessions</a>
</dt>
</dl>
<dt>6.3.  <a href="#init-keys">Generating Session Keys</a>
</dt>
</dl>
<dt>7.  <a href="#exchange">Exchanging Stanzas</a>
</dt>
<dl>
<dt>7.1.  <a href="#exchange-separate">Encryptable Content</a>
</dt>
<dt>7.2.  <a href="#exchange-encrypt">Encryption</a>
</dt>
<dt>7.3.  <a href="#exchange-send">Sending an Encrypted Stanza</a>
</dt>
<dt>7.4.  <a href="#exchange-decrypt">Decryption</a>
</dt>
</dl>
<dt>8.  <a href="#rekey">Re-Key Exchange</a>
</dt>
<dl>
<dt>8.1.  <a href="#rekey-init">Re-Key Initiation</a>
</dt>
<dt>8.2.  <a href="#rekey-accept">Re-Key Acceptance</a>
</dt>
<dt>8.3.  <a href="#rekey-publish">Publishing Old MAC Values</a>
</dt>
</dl>
<dt>9.  <a href="#terminate">Esession Termination</a>
</dt>
<dt>10.  <a href="#sign">Signature Generation</a>
</dt>
<dl><dt>10.1.  <a href="#sign-canon">Canonical Form (Informative)</a>
</dt></dl>
<dt>11.  <a href="#sec">Security Considerations</a>
</dt>
<dl>
<dt>11.1.  <a href="#sec-prng">Random Numbers</a>
</dt>
<dt>11.2.  <a href="#sec-rekey">Re-Keying Limits</a>
</dt>
<dt>11.3.  <a href="#sec-keys">Verifying Keys</a>
</dt>
<dt>11.4.  <a href="#sec-replay">Replay Attacks</a>
</dt>
<dt>11.5.  <a href="#sec-unencrypted">Unencrypted Esessions</a>
</dt>
<dt>11.6.  <a href="#sec-storage">Storage</a>
</dt>
<dt>11.7.  <a href="#sec-offline">Offline Esessions</a>
</dt>
<dt>11.8.  <a href="#sec-general">Extra Responsabilities of Implementors</a>
</dt>
<dt>11.9.  <a href="#sec-mandatory">Mandatory to Implement Technologies</a>
</dt>
<dl>
<dt>11.9.1.  <a href="#sec-mandatory-encryption">Encryption Algorithms</a>
</dt>
<dt>11.9.2.  <a href="#sec-mandatory-sign">Key Signing Algorithms</a>
</dt>
<dt>11.9.3.  <a href="#sec-mandatory-public">Public Signature-Verification-Key Formats</a>
</dt>
<dt>11.9.4.  <a href="#sec-mandatory-hash">Hash Algorithms</a>
</dt>
<dt>11.9.5.  <a href="#sec-mandatory-compress">Compression Algorithms</a>
</dt>
</dl>
</dl>
<dt>12.  <a href="#iana">IANA Considerations</a>
</dt>
<dt>13.  <a href="#registrar">Jabber Registrar Considerations</a>
</dt>
<dl>
<dt>13.1.  <a href="#registrar-ns">Namespaces</a>
</dt>
<dt>13.2.  <a href="#registrar-formtype">Field Standardization</a>
</dt>
</dl>
<dt>14.  <a href="#schema">XML Schemas</a>
</dt>
<dt>15.  <a href="#keys">Public Key Publication and Retrieval</a>
</dt>
<dt>16.  <a href="#open">Open Issues</a>
</dt>
<dl>
<dt>16.1.  <a href="#open-tothink">To Think About</a>
</dt>
<dt>16.2.  <a href="#open-todo">To Do</a>
</dt>
</dl>
<dt><a href="#notes">Notes</a></dt>
<dt><a href="#revs">Revision History</a></dt>
</dl></div>
<p><hr></p>
<h2>1.
       <a name="intro">Introduction</a>
</h2>
  <p class="" style="">End-to-end encryption is a desirable feature for any communication technology. Ideally, such a technology would design encryption in from the beginning and would forbid unencrypted communications. Realistically, most communication technologies have not been designed in that manner, and Jabber/XMPP technologies are no exception. In particular, the original Jabber technologies developed in 1999 did not include end-to-end encryption by default. PGP-based encryption of message bodies and signing of presence information was added as an extension to the core protocols in the year 2000; this extension is documented in <span class="ref" style="">Current Jabber OpenPGP Usage</span>  [<a href="#nt-id2250669">1</a>]. When the core protocols were formalized within the Internet Standards Process by the IETF's XMPP Working Group in 2003, a different extension was defined using S/MIME-based signing and encryption of CPIM-formatted messages (see <span class="ref" style="">RFC 3862</span>  [<a href="#nt-id2250627">2</a>]) and PIDF-formatted presence information (see <span class="ref" style="">RFC 3863</span>  [<a href="#nt-id2250650">3</a>]); this extension is specified in <span class="ref" style="">RFC 3923</span>  [<a href="#nt-id2250694">4</a>].</p>
  <p class="" style="">For reasons described more fully below, the foregoing proposals (and others not mentioned) have not been widely implemented and deployed. This is unfortunate, since an open communication protocol needs to enable end-to-end encryption in order to be seriously considered for deployment by a broad range of users. This proposal describes a different approach to end-to-end encryption for use by entities that communicate using XMPP. The approach taken herein essentially translates the semantics of the secure shell protocol (SSH) into the syntax of XMPP, with some adjustments that reflect reports of security issues with SHA-1 and insights gleaned from implementation of "off-the-record" (OTR) communication in the Gaim encryption plugin as described in <span class="ref" style="">Off-the-Record Communication</span>  [<a href="#nt-id2250454">5</a>]. The result is a protocol for encrypted sessions or "ESessions".</p>
<h2>2.
       <a name="background">Background</a>
</h2>
  <p class="" style="">As specified in <span class="ref" style="">RFC 3920</span>  [<a href="#nt-id2250486">6</a>], XMPP is an XML streaming protocol that enables the near-real-time exchange of XML fragments between any two (or more) network endpoints. To date, the main application built on top of the core XML streaming layer is instant messaging (IM) and presence, the base extensions for which are specified in <span class="ref" style="">RFC 3921</span>  [<a href="#nt-id2250514">7</a>]. There are three first-level elements of XML streams (&lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;); each of these "XML stanza" types has different semantics, which can complicate the task of defining a generalized approach to end-to-end encryption for XMPP. In addition, XML stanzas can be extended (via properly-namespaced child elements) for a wide variety of functionality. The chosen approach should enable encryption of several complete XML elements rather than only parts thereof (e.g., only the XML character data of the message &lt;body/&gt; element as in <span style="font-weight: bold">JEP-0027</span>).</p>
  <p class="" style="">XMPP is a session-oriented communication technology: normally, a client authenticates with a server and maintains a long-lived connection that defines the client's XMPP session. Such stream-level sessions are secured via channel encryption using Transport Level Security (<span class="ref" style="">RFC 2246</span>  [<a href="#nt-id2255652">8</a>]), as specified in Section 5 of <span style="font-weight: bold">RFC 3920</span>. However, there is no guarantee that all hops will implement or enforce channel encryption (or that intermediate routers are trustworthy), which makes end-to-end encryption desirable.</p>
  <p class="" style="">The session metaphor also applies to communication between endpoints: for instance, in IM applications, most instant messaging exchanges occur in bursts within limited time periods (e.g., two people may send a fairly large number of messages during a five-minute chat and then not exchange messages again for hours or even days). The XML stanzas exchanged during such a session may not be limited to &lt;message/&gt; stanzas; for instance, the session may be triggered by a change in one of the parties' presence status (e.g., changing from away to available) and the session may involve the exchange of &lt;iq/&gt; stanzas (e.g., to transfer a file as specified in <span class="ref" style="">File Transfer</span>  [<a href="#nt-id2255699">9</a>]). Endpoints may want to encrypt the stanzas they send to each other in such a way that the stanzas cannot be understood by untrusted mediating entities (such as servers) except to the extent required to understand the necessary routing information. (One complicating factor is that routing information may include not only the stanza's 'to', 'from', 'type, and 'id' attributes, but also <span class="ref" style="">Advanced Message Processing</span>  [<a href="#nt-id2255721">10</a>] extensions.)</p>
  <p class="" style="">The foregoing XMPP communications exist in the context of a one-to-one communication session between two entities. However, several forms of XMPP communication exist outside the context of one-to-one communication sessions:</p>
  <ul>
    <li>Many-to-many sessions, such as a text conference in a chatroom as specified in <span class="ref" style="">Multi-User Chat</span>  [<a href="#nt-id2255756">11</a>].</li>
    <li>One-to-many "broadcast", such as undirected presence stanzas sent from one user to many contacts (see <span style="font-weight: bold">RFC 3921</span>) and data syndication implemented using <span class="ref" style="">Publish-Subscribe</span>  [<a href="#nt-id2255786">12</a>].</li>
    <li>One-to-one communications that are stored for later delivery rather than delivered immediately, such as so-called "offline messages".</li>
  </ul>
  <p class="" style="">Ideally, any technology for end-to-end encryption in XMPP could be extended to cover these scenarios as well as one-to-one communication sessions. However, both many-to-many sessions and one-to-many broadcast are deemed out of scope for this JEP. Offline communications are handled via a simple extension to the protocol for one-to-one sessions between two entities that are online simultaneously (see below).</p>
  <p class="" style="">Because XMPP is a session-oriented communication technology, encryption schemes that are appropriate for less dynamic technologies may not be appropriate for XMPP. XMPP, with its in-order delivery of XML stanzas, is able to take advantage of encryption approaches that are not feasible for less dynamic technologies. In particular, existing approaches to encryption of Internet communications have generally assumed that the "thing" to be encrypted has a stable identity or is best understood as a standalone object (e.g., a file or email message); the term "object encryption" well captures this assumption. Both <span style="font-weight: bold">JEP-0027</span> and <span style="font-weight: bold">RFC 3923</span> assume that XMPP communications are more like the exchange of email messages than they are like an interactive session -- while <span style="font-weight: bold">JEP-0027</span> uses "old-style" PGP object encryption and <span style="font-weight: bold">RFC 3923</span> uses "new-style" S/MIME object encryption, both specify the use of object encryption. </p>
  <p class="" style="">However, the session-oriented nature of XMPP may imply that the focus should be on "session encryption" rather than "object encryption". The paradigm for XMPP encryption may be something closer to the widely-deployed Secure Shell technology (see <span class="ref" style="">SSH Protocol Architecture</span>  [<a href="#nt-id2255916">13</a>] and <span class="ref" style="">SSH Transport Layer Protocol</span>  [<a href="#nt-id2255889">14</a>]) than to traditional encryption of files and standalone email messages. In many ways, Secure Shell (or, more specifically, OTR) is the conceptual model for the current proposal.</p>
  <p class="" style="">Therefore, this JEP specifies a method for encrypted sessions ("ESessions") that takes advantage of the inherent possibilities and strengths of session encryption as opposed to object encryption. The basic concept is that of an encrypted session which acts as a secure tunnel between two endpoints. Once the tunnel is established, the content of all one-to-one XML stanzas exchanged between the endpoints will be encrypted and then transmitted within a "wrapper" protocol element.</p>
<h2>3.
       <a name="terms">Terminology</a>
</h2>
  <div class="indent">
<h3>3.1 <a name="terms-personae">Dramatis Personae</a>
</h3>
    <p class="" style="">This JEP introduces two characters to help the reader follow the necessary exchanges:</p>
    <ol start="1" type="">
      <li>"Alice" is the name of the initiator of the ESession. Within the scope of this JEP, we stipulate that her fully-qualified JID is: &lt;alice@example.org/pda&gt;.</li>
      <li>"Bob" is the name of the other participant in the ESession started by Alice. Within the scope of this JEP, his fully-qualified JID is: &lt;bob@example.com/laptop&gt;.</li>
    </ol>
    <p class="" style="">While Alice and Bob are introduced as "end users", they are simply meant to be examples of Jabber entities. Any directly addressable Jabber entity may participate in an Esession.</p>
  </div>
<h2>4.
       <a name="reqs">Requirements</a>
</h2>
  <div class="indent">
<h3>4.1 <a name="reqs-sec">Security Requirements</a>
</h3>
    <p class="" style="">This JEP stipulates the following security requirements for end-to-end encryption of XMPP communications:</p>
    <ul>
      <li>Confidentiality</li>
      <li>Integrity</li>
      <li>Replay protection</li>
      <li>Perfect forward secrecy</li>
      <li>Authentication</li>
      <li>Repudiability</li>
    </ul>
    <p class="" style="">Each of these requirements is explained in greater depth below.</p>
    <div class="indent">
<h3>4.1.1 <a name="reqs-encrypt">Confidentiality</a>
</h3>
      <p class="" style="">The one-to-one XML stanzas exchanged between two entities MUST NOT be understandable to any other entity that might intercept the communications.</p>
    </div>
    <div class="indent">
<h3>4.1.2 <a name="reqs-integrity">Integrity</a>
</h3>
      <p class="" style="">Alice and Bob MUST be sure that no other entity may change the content of the XML stanzas they exchange, or remove or insert stanzas into the Esession undetected.</p>
    </div>
    <div class="indent">
<h3>4.1.3 <a name="reqs-replay">Replay Protection</a>
</h3>
      <p class="" style="">Alice or Bob MUST be able to identify and reject any communications that are copies of their previous communications resent by another entity.</p>
    </div>
    <div class="indent">
<h3>4.1.4 <a name="reqs-forward">Perfect Forward Secrecy</a>
</h3>
      <p class="" style="">The encrypted communication MUST NOT be revealed even if long-lived keys are compromised in the future (e.g., Steve steals Bob's computer).</p>
    </div>
    <div class="indent">
<h3>4.1.5 <a name="reqs-auth">Authentication</a>
</h3>
      <p class="" style="">Each party to a conversation MUST know that the other party is who he says he is (Alice must be able to know that Bob really is Bob, and vice versa).  [<a href="#nt-id2256127">15</a>]</p>
    </div>
    <div class="indent">
<h3>4.1.6 <a name="reqs-repudiate">Repudiability</a>
</h3>
      <p class="" style="">Alice and Bob MUST be able to repudiate any stanza that occurs within an Esession. After an Esession has finished, it SHOULD NOT be possible to <span style="font-style: italic">prove cryptographically</span> that any transcript has not been modified by a third party.  [<a href="#nt-id2256154">16</a>]</p>
    </div>
  </div>
  <div class="indent">
<h3>4.2 <a name="reqs-xmpp">Application Requirements</a>
</h3>
    <p class="" style="">In addition to the foregoing security profile, this JEP also stipulates the following application-specific requirements for encrypted communication in the context of Jabber/XMPP technologies:</p>
    <ul>
      <li>Generality</li>
      <li>Implementability</li>
      <li>Usability</li>
      <li>Flexability</li>
      <li>Interoperability</li>
      <li>Offline "sessions"</li>
    </ul>
    <p class="" style="">Each of these is explained in greater depth below.</p>
    <div class="indent">
<h3>4.2.1 <a name="reqs-generality">Generality</a>
</h3>
      <p class="" style="">The solution should be generally applicable to any XML stanza type (&lt;message/&gt;, &lt;presence/&gt;, &lt;iq/&gt;) sent between two entities. It is deemed acceptable for now if the solution does not apply to many-to-many stanzas (e.g., groupchat messages sent within the context of multi-user chat) or one-to-many stanzas (e.g., presence "broadcasts" and pubsub notifications); end-to-end encryption of such stanzas may require separate solutions or extensions to the one-to-one session solution.</p>
    </div>
    <div class="indent">
<h3>4.2.2 <a name="reqs-implement">Implementability</a>
</h3>
      <p class="" style="">The only good security technology is an implemented security technology. The solution should be one that typical client developers can implement in a relatively straightforward and consistent fashion.</p>
    </div>
    <div class="indent">
<h3>4.2.3 <a name="reqs-usable">Usability</a>
</h3>
      <p class="" style="">The requirement of usability takes implementability one step further by stipulating that the solution must be one that organizations may deploy and humans may use with 100% transparency (with the ease-of-use of https:). Experience has shown that: solutions requiring a full public key infrastructure do not get widely deployed, and solutions requiring any user action are not widely used. We can do better.</p>
    </div>
    <div class="indent">
<h3>4.2.4 <a name="reqs-flexible">Flexibility</a>
</h3>
      <p class="" style="">The solution should be compatible with existing (and future) cryptographic algorithms and identity certification schemes (including X.509 and PGP).</p>
    </div>
    <div class="indent">
<h3>4.2.5 <a name="reqs-usable">Interoperability</a>
</h3>
      <p class="" style="">Ideally, it would be possible for an XMPP user to exchange encrypted messages (and, potentially, presence information) with users of non-XMPP messaging systems.</p>
    </div>
    <div class="indent">
<h3>4.2.6 <a name="reqs-offline">Offline Sessions</a>
</h3>
      <p class="" style="">Ideally, it should be possible to encrypt one-to-one communications that are stored for later delivery rather than delivered immediately, such as so-called "offline messages".</p>
    </div>
  </div>
<h2>5.
       <a name="disco">Discovering Support</a>
</h2>
  <p class="" style="">Before attempting to engage in an ESession with Bob, Alice SHOULD discover whether he supports this protocol, using either <span class="ref" style="">Service Discovery</span>  [<a href="#nt-id2256373">17</a>] or the presence-based profile of <span style="font-weight: bold">JEP-0030</span> specified in <span class="ref" style="">Entity Capabilities</span>  [<a href="#nt-id2256395">18</a>].</p>
  <p class="" style="">The normal course of events is for Alice to authenticate with her server, retrieve her roster (see <span style="font-weight: bold">RFC 3921</span>), send initial presence to her server, and then receive presence information from all the contacts in her roster. If the presence information she receives from some contacts does not include capabilities data (per <span style="font-weight: bold">JEP-0115</span>), Alice SHOULD then send a service discovery information ("disco#info") request to each of those contacts (in accordance with <span style="font-weight: bold">JEP-0030</span>). Such initial service discovery stanzas MUST NOT be considered part of encrypted communication sessions for the purposes of this JEP, since they perform a "bootstrapping" function that is a prerequisite to encrypted communications. The disco#info request sent from Alice to Bob might look as follows:</p>
  <p class="caption">Example 1. Alice Queries Bob for Esession Support via Disco</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='alice@example.org/pda'
    to='bob@example.com/laptop'
    id='disco1'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'/&gt;
&lt;/iq&gt;
  </pre></div>
  <p class="" style="">If Bob sends a disco#info reply and he supports the protocol defined herein, then he MUST include a service discovery feature variable of "http://jabber.org/protocol/esession".</p>
  <p class="caption">Example 2. Bob Returns disco#info Data</p>
<div class="indent"><pre>
&lt;iq type='result'
    from='bob@example.com/laptop'
    to='alice@example.org/pda'
    id='disco1'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'&gt;
    &lt;identity category='client' type='pc'/&gt;
    ...
    &lt;feature var='http://jabber.org/protocol/esession'/&gt;
    ...
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
<h2>6.
       <a name="init">ESession Initiation</a>
</h2>
  <p class="" style="">The process for establishing an ESession is essentially a translation into XMPP syntax of the SSH transport mechanism for establishing a secure session over an insecure transport (see <span style="font-weight: bold">SSH Transport Layer Protocol</span>). Specifically, as in SSH, ESession uses a Diffie-Hellman key exchange algorithm (see <span class="ref" style="">RFC 2631</span>  [<a href="#nt-id2256494">19</a>]) in the initial negotation (although, as we shall see, it does not use SHA-1 as the hashing algorithm).</p>
  <p class="" style="">When Alice wishes to establish an ESession with Bob, Alice may choose between two different methods of performing the initial Diffie-Hellman key exchange, depending on whether Bob is online or not. Note: Alice MUST NOT initiate a new Esession with Bob if she already has one established with him.</p>

  <div class="indent">
<h3>6.1 <a name="init-online">Online Diffie-Hellman Key Exchange</a>
</h3>
    <p class="" style="">If Alice believes Bob may be online then she SHOULD retrieve Bob's long-term public signature-verification keys (see <a href="#keys">Public Key Publication and Retrieval</a>) and then use the protocol specified in <span class="ref" style="">Chat Session Negotiation</span>  [<a href="#nt-id2256559">20</a>] to negotiate the initial Diffie-Hellman key. In this aggressive exchange the first two messages negotiate policy, swap Diffie-Hellman public values and the ancillary data necessary for the exchange and authentication. The second message also authenticates the responder. The third message authenticates the initiator and exchanges the final Diffie-Hellman public value.</p>
    <div class="indent">
<h3>6.1.1 <a name="init-request">Esession Request</a>
</h3>
      <p class="" style="">Alice MUST specify each of the Esession options (algorithms etc.) she is willing to use, in her order of preference (see <a href="#sec-mandatory">Mandatory to Implement Technologies</a>):</p>
      <ol start="1" type="">
        <li><p class="" style="">The list of Modular Exponential (MODP) group numbers (as specified in <span class="ref" style="">RFC 2409</span>  [<a href="#nt-id2256625">21</a>] or <span class="ref" style="">RFC 3526</span>  [<a href="#nt-id2256648">22</a>]) she is willing to use for Diffie-Hellman key exchange (valid group numbers include 1,2,3,4,5,14,15,16,17 and 18)</p></li>
        <li><p class="" style="">Stanza symmetric encryption algorithm names</p></li>
        <li><p class="" style="">Hash algorithm names</p></li>
        <li><p class="" style="">Compression algorithm names</p></li>
        <li><p class="" style="">The list of stanza types she is willing to encrypt and decrypt</p></li>
        <li><p class="" style="">Whether or not both entities MUST be connected securely to their servers (see Section 5 of <span style="font-weight: bold">RFC 3920</span>)</p></li>
        <li><p class="" style="">The minimum number of stanzas that MUST be exchanged before an entity MAY initiate a key re-exchange (1 - every stanza, 100 - every hundred stanzas). This value MUST be less than 2<span class="super" style="">32</span> (see <a href="#sec-rekey">Re-Keying Limits</a>)</p></li>
        <li><p class="" style="">The Base64 encoded (in accordance with Section 3 of <span class="ref" style="">RFC 3548</span>  [<a href="#nt-id2256756">23</a>]) SHA-256 fingerprint (PKID) of each of Bob's public signature-verification keys that she found acceptable (see <a href="#sec-keys">Verifying Keys</a>)</p></li>
      </ol>
    <p class="caption">Example 3. Alice Requests an ESession</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='form' xmlns='jabber:x:data'&gt;
      &lt;field type='hidden' var='FORM_TYPE'&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type='boolean' var='logging'&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      ...
      &lt;field type='list-single' var='modp'&gt;
        &lt;option&gt;&lt;value&gt;5&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;14&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;2&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;1&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type='list-single' var='crypt_algs'&gt;
        &lt;option&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;twofish256-ctr&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;aes128-ctr&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type='list-single' var='hash_algs'&gt;
        &lt;option&gt;&lt;value&gt;whirlpool&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type='list-single' var='compress'&gt;
        &lt;option&gt;&lt;value&gt;none&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type='list-multi' var='stanzas'&gt;
        &lt;option&gt;&lt;value&gt;message&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;iq&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;presence&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type='boolean' var='secure'&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type='text-single' var='rekey_freq'&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type='list-multi' var='accept_pkids'&gt;
        &lt;option&gt;&lt;value&gt; ** PKID ** &lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt; ** PKID ** &lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      ...
    &lt;/x&gt;
  &lt;/feature&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">If Bob does not support one or more of the options in each Esession field (except the 'accept_pkids' field), then he SHOULD return a &lt;feature-not-implemented/&gt; error (but he MAY return no error if, for example, he does not want to reveal his presence to Alice for whatever reason):</p>
    <p class="caption">Example 4. Bob Informs Alice that Her Options Are Not Supported</p>
<div class="indent"><pre>
&lt;message type='error'
         from='bob@example.com/laptop'
         to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    ...
  &lt;/feature&gt;
  &lt;error code='501' type='cancel'&gt;
    &lt;feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
  &lt;/error&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Either Bob or Alice MAY attempt to initiate a new ESession after any error during the initiation process. However, both MUST consider the previous negotiation to have failed and MUST discard any information learned through the previous negotiation.</p>
    </div>
    <div class="indent">
<h3>6.1.2 <a name="init-prep">Diffie-Hellman Preparation (Bob)</a>
</h3>
      <p class="" style="">If Bob is willing to start an ESession with Alice, he SHOULD retrieve Alice's long-term public signature-verification keys. He MUST select one of the options from each of the Esession fields he received from Alice including one of the MODP groups (see <span class="ref" style="">RFC 3766</span>  [<a href="#nt-id2256913">24</a>] or <span style="font-weight: bold">RFC 3526</span> for recommendations regarding balancing the sizes of symmetric cipher blocks and Diffie-Hellman moduli). Each MODP group has at least two well known constants: a large prime number p, and a generator g for a subgroup of GF(p). Bob MUST then perform the following computations (where n is the number of bits per encryption block for the selected encryption algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Generate the initial value of C<span class="sub" style="">A</span> with n-1 random bits (C<span class="sub" style="">A</span> is the encryption block counter for stanzas sent from Alice to Bob)</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> + 2<span class="super" style="">n-1</span> (where C<span class="sub" style="">B</span> is the counter for stanzas sent from Bob to Alice)</p></li>
        <li><p class="" style="">Generate a secret random number y (where 2<span class="super" style="">2n-1</span> &lt; y &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate d = g<span class="super" style="">y</span> mod p</p></li>
        <li><p class="" style="">Generate an opaque unique key identifier (KID) for d</p></li>
      </ol>
    </div>
    <div class="indent">
<h3>6.1.3 <a name="init-response">Esession Response</a>
</h3>
    <p class="" style="">Bob responds to Alice specifying the Esession options he selected.</p>
    <p class="" style="">If Bob is willing to start an ESession with Alice, then instead of providing the PKID of his public key that he selected, Bob MUST specify the Base64 encoded SHA-256 fingerprint (PKID) of each of Alice's public signature-verification keys that he finds acceptable (see <a href="#sec-keys">Verifying Keys</a>). Note: The submited values for the 'accept_pkids' field do not correspond to the options he received. The value of the 'rekey_freq' field MUST be less than 2<span class="super" style="">32</span> and greater than or equal to the value specified by Alice.</p>
    <p class="" style="">In addition to the fields he received from Alice, Bob MUST include the KID and the Base64 encoded values of d and C<span class="sub" style="">A</span>. If Alice selected one or more of his public keys, and if Bob has access to a long-lived private signing key that corresponds to one of those keys  [<a href="#nt-id2257220">25</a>], then he MUST also include the PKID. Otherwise (for example, if Bob is unable to publish keys to his server or if Alice is unable to access keys published via his server  [<a href="#nt-id2257228">26</a>]), Bob MAY include one of his Base64 encoded public keys. In either case, Bob MUST include the Base64 encoded signature (see <a href="#sign">Signature Generation</a>) of the <span style="font-style: italic">content</span> of the data form (excluding the 'signs' field).</p>
    <p class="" style="">However, if Bob is ready to initiate a one-to-one chat session with Alice (see <span style="font-weight: bold">Chat Session Negotiation</span>) but he is unwilling to start an ESession, then he SHOULD terminate the Esession negotiation by not specifying any of the five extra values in his response.</p>
    <p class="caption">Example 5. Bob Responds to Alice (with Public Key)</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var='FORM_TYPE'&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='logging'&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      ...
      &lt;field var='modp'&gt;&lt;value&gt;5&lt;/value&gt;&lt;/field&gt;
      &lt;field var='crypt_algs'&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/field&gt;
      &lt;field var='hash_algs'&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/field&gt;
      &lt;field var='compress'&gt;&lt;value&gt;none&lt;/value&gt;&lt;/field&gt;
      &lt;field var='stanzas'&gt;&lt;value&gt;message&lt;/value&gt;&lt;/field&gt;
      &lt;field var='secure'&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var='rekey_freq'&gt;&lt;value&gt;50&lt;/value&gt;&lt;/field&gt;
      &lt;field var='accept_pkids'&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      ...
      &lt;field var='counter'&gt;
        &lt;value&gt; ** Base64 encoded initial counter value ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='kid'&gt;
        &lt;value&gt; ** KID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='key'&gt;
        &lt;value&gt; ** Base64 encoded value of d ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='pkey'&gt;
        &lt;value&gt; ** Base64 encoded public key ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='signs'&gt;
        &lt;value&gt; ** Base64 encoded signature of form ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
&lt;/message&gt;
    </pre></div>
    <p class="caption">Example 6. Bob Responds to Alice (with PKID)</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      ...
      &lt;field var='counter'&gt;
        &lt;value&gt; ** Base64 encoded initial counter value ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='kid'&gt;
        &lt;value&gt; ** KID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='key'&gt;
        &lt;value&gt; ** Base64 encoded value of d ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='pkids'&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='signs'&gt;
        &lt;value&gt; ** Base64 encoded signature of form ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">If Alice provided a PKID but Bob did not provide a signature then she MAY send a failure notice to him. If Bob sent Alice a public key but she could not verify it belongs to him via secure out-of-band communication (see <a href="#sec-keys">Verifying Keys</a>) then she SHOULD send a failure notice to him. If Bob provided an invalid signature (see <a href="#sign">Signature Generation</a>) then she MUST send a failure notice to him.</p>
    <p class="caption">Example 7. Alice Signals that ESession Negotiation Failed (Unacceptable Signature)</p>
<div class="indent"><pre>
&lt;message type='error'
         from='alice@example.org/pda'
         to='bob@example.com/laptop'&gt;
  &lt;error code='406' type='modify'&gt;
    &lt;feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
    &lt;invalid-signature xmlns='http://jabber.org/protocol/esession#error'/&gt;
  &lt;/error&gt;
&lt;/message&gt;
    </pre></div>
    </div>
    <div class="indent">
<h3>6.1.4 <a name="init-prep2">Diffie-Hellman Preparation (Alice)</a>
</h3>
      <p class="" style="">After verifying Bob's signature, Alice can be certain that the value of d was actually generated by Bob. Alice MUST use the value of d and the Esession options specified in Bob's response to perform the following steps (where n is the number of bits per encryption block for the agreed encryption algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Set the initial value of C<span class="sub" style="">A</span> to the counter value she received from Bob</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> + 2<span class="super" style="">n-1</span></p></li>
        <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
        <li><p class="" style="">Generate an opaque unique key identifier (KID) for e</p></li>
        <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (this is the shared secret)</p></li>
      </ol>
    </div>
    <div class="indent">
<h3>6.1.5 <a name="init-complete">Diffie-Hellman Completion</a>
</h3>
    <p class="" style="">Alice then completes the Diffie-Hellman negotiation by sending Bob the KID and the Base64 encoded value of e. If Bob selected one or more of her public keys, and if Alice has access to a long-lived private signing key that corresponds to one of those keys, then she MUST also include the PKID. Otherwise, Alice MAY include one of her Base64 encoded public keys (see <a href="#init-response">Esession Response</a> example). In either case, Alice MUST include the Base64 encoded signatures (see <a href="#sign">Signature Generation</a>) of the <span style="font-style: italic">content</span> of the data form from her initial Esession request and of the <span style="font-style: italic">content</span> of this data form (excluding the 'signs' field).</p>
    <p class="" style="">Alice MAY also send encrypted content (see the <a href="#exchange">Exchanging Stanzas</a> section of this document) in the same stanza as the Diffie-Hellman completion.</p>
    <p class="caption">Example 8. Alice Completes Diffie-Hellman Negotitation (with PKID)</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;init xmlns='http://jabber.org/protocol/esession#init'&gt;
    &lt;x xmlns='jabber:x:data'&gt;
      &lt;field var='kid'&gt;&lt;value&gt; ** KID ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var='key'&gt;&lt;value&gt; ** Base64 encoded value of e ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var='pkids'&gt;&lt;value&gt; ** PKID ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var='req_sign'&gt;&lt;value&gt; ** Base64 encoded signature of her previous form ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var='signs'&gt;&lt;value&gt; ** Base64 encoded signature of this form ** &lt;/value&gt;&lt;/field&gt;
    &lt;/x&gt;
  &lt;/init&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">If Bob provided a PKID but Alice did not provide a signature then he MAY send a failure notice to her. If Alice sent Bob a public key but he could not verify it belongs to her via secure out-of-band communication (see <a href="#sec-keys">Verifying Keys</a>) then he SHOULD send a failure notice to her. If Alice provided an invalid signature (see <a href="#sign">Signature Generation</a>) then he MUST send a failure notice to her. If Bob sends a failure notice then he SHOULD ignore any encrypted content in the stanza.</p>
    <p class="" style="">If no error occurs, Bob MUST calculate K = e<span class="super" style="">y</span> mod p (the shared secret). Alice and Bob then have the same value for K and the key exchange is complete.</p>
    </div>
  </div>



<div class="indent">
<h3>6.2 <a name="init-offline">Offline Diffie-Hellman Key Exchange</a>
</h3>
  <p class="" style="">As described below, offline negotiation of an Esession is in essence a special case of online negotiation. Bob MAY publish a set of Esession options just before he goes offline (see <a href="#sec-offline">Offline Esessions</a> Security Considerations) to allow entities that subscribe to his presence to initiate Esessions and send encrypted stanzas to him while he is offline. He MAY also publish <span style="font-style: italic">another</span> similar set of relatively long-lived  [<a href="#nt-id2256934">27</a>] Esession options that any entity MAY use for the same purpose.</p>
    <div class="indent">
<h3>6.2.1 <a name="init-publish">Publishing Esession Options</a>
</h3>
      <p class="" style="">In order to publish either set of his offline Esession options Bob MUST perform the following steps:</p>
      <ol start="1" type="">
        <li><p class="" style="">Generate a secret random number y (where 2<span class="super" style="">2n-1</span> &lt; y &lt; p - 1, where n is the largest number of bits per encryption block for the encryption algorithms he is willing to use)</p></li>
        <li><p class="" style="">Select a MODP group (that defines the constants p and g)</p></li>
        <li><p class="" style="">Calculate d = g<span class="super" style="">y</span> mod p</p></li>
        <li><p class="" style="">Generate an opaque unique key identifier (KID) for d (typically by calculating a hash of d, since this KID SHOULD be unique across all Esessions)</p></li>
        <li><p class="" style="">Store the values of y and d and the KID in a secure way, so that he can retrieve them when he comes back online (idealy even if that is using a different client and/or a different machine)</p></li>
        <li><p class="" style="">Publish each of the Esession options he is willing to use (see <a href="#init-request">Esession Request</a>) including the value of d and the KID. He SHOULD do this through his own server using the disco#publish-info feature (as <a href="http://mail.jabber.org/pipermail/standards-jig/2005-July/008131.html">NOT SPECIFIED</a> in <span style="font-weight: bold">JEP-0030</span>) or a similar protocol (out of scope for this JEP).</p></li>
      </ol>
      <p class="" style="">Note: The single specified MODP group MUST be the one Bob used to generate d. The list of stanza types he is willing to decrypt MUST NOT include the value 'iq'. Bob MUST also include the list of the PKIDs of all his public signature-verification keys that he can sign for, and the corresponding list of Base64 encoded signatures (see <a href="#sign">Signature Generation</a>) of the <span style="font-style: italic">content</span> of the data form (excluding the 'signs' field).</p>
      <p class="" style=""><span style="font-style: italic">Note: This publishing protocol is highly preliminary and depends on a separate proposal.</span></p>
      <p class="caption">Example 9. Bob Publishes His Esession Options for His Subscribers</p>
<div class="indent"><pre>
&lt;iq type='set' from='bob@example.com/laptop' id='es2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info-subscription'
         node='http://jabber.org/protocol/esession#subscription'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var='FORM_TYPE'&gt;
        &lt;value&gt;http://jabber.org/protocol/esession&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='logging'&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/field&gt;
      ...
      &lt;field var='modp'&gt;
        &lt;value&gt;2&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='crypt_algs'&gt;
        &lt;value&gt;aes256-ctr&lt;/value&gt;
        &lt;value&gt;twofish256-ctr&lt;/value&gt;
        &lt;value&gt;aes128-ctr&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='hash_algs'&gt;
        &lt;value&gt;whirlpool&lt;/value&gt;
        &lt;value&gt;sha256&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='compress'&gt;
        &lt;value&gt;none&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='stanzas'&gt;
        &lt;value&gt;message&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='secure'&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='rekey_freq'&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='kid'&gt;
        &lt;value&gt; ** KID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='key'&gt;
        &lt;value&gt; ** Base64 encoded value of d ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='pkids'&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='signs'&gt;
        &lt;value&gt; ** Base64 encoded signature of form ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded signature of form ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">Bob MAY publish his Esession options for all entities using the same protocol except for the 'xmlns' and 'node' attributes of the &lt;query/&gt; element:</p>
      <p class="caption">Example 10. Bob Publishes His Esession Options for All Entities</p>
<div class="indent"><pre>
&lt;iq type='set' from='bob@example.com/laptop' id='es2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      ...
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
    </div>
    <div class="indent">
<h3>6.2.2 <a name="init-offreq">Requesting Offline Esession Options</a>
</h3>
      <p class="" style="">If Alice believes Bob is offline she SHOULD request his Esession options and his long-term public signature-verification keys (see <a href="#keys">Public Key Publication and Retrieval</a>) from his server.</p>
      <p class="" style="">If Alice is subscribing to Bob's presence she MUST request his Esession Options exclusively for subscribers.</p>
      <p class="caption">Example 11. Alice asks Bob's Server for his Esession Options (Subscribers)</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='alice@example.org/pda'
    to='bob@example.com'
    id='es3'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession#subscription'/&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">If Alice is not subscribing to Bob's presence (or if Bob has no Esession Options exclusively for subscribers) she MUST use the following request instead.</p>
      <p class="caption">Example 12. Alice asks Bob's Server for his Esession Options (All Entities)</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='alice@example.org/pda'
    to='bob@example.com'
    id='es3'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession'/&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">If, after receiving Bob's public keys and Esession options, Alice is unable to verify any of Bob's signatures (see <a href="#sign">Signature Generation</a>) then she MAY decide to proceed no further, since she cannot be sure who will be able to decrypt her stanzas.</p>
    </div>
    <div class="indent">
<h3>6.2.3 <a name="init-prep3">Diffie-Hellman Preparation (Offline)</a>
</h3>
      <p class="" style="">Alice MUST select one of the options from each of Bob's Esession fields. If she cannot support any of the options in a field (except the 'pkids' and 'signs' fields) then she MUST not send encrypted stanzas to Bob while he is offline.</p>
      <p class="" style="">Alice MUST use the value of d and the MODP group specified in Bob's Esession options to perform the following steps (where n is the number of bits per encryption block for the selected encryption algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Generate the initial value of C<span class="sub" style="">A</span> with n-1 random bits (C<span class="sub" style="">A</span> is the encryption block counter for stanzas sent from Alice to Bob)</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> + 2<span class="super" style="">n-1</span> (where C<span class="sub" style="">B</span> is the counter for stanzas sent from Bob to Alice - in case Bob comes online before Alice terminates the Esession)</p></li>
        <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
        <li><p class="" style="">Generate an opaque unique key identifier (KID) for e</p></li>
        <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (the shared secret)</p></li>
      </ol>
    </div>
    <div class="indent">
<h3>6.2.4 <a name="init-start">Starting an Offline Esession</a>
</h3>
      <p class="" style="">Alice then sends Bob the KID and the Base64 encoded values of e and C<span class="sub" style="">A</span>. She SHOULD also include the list of the PKIDs of all her public signature-verification keys that she can sign for, and the corresponding list of Base64 encoded signatures (see <a href="#sign">Signature Generation</a>) of the <span style="font-style: italic">content</span> of the data form (excluding the 'signs' field).</p>
      <p class="" style="">She also specifies which of Bob's Esession options she selected. Note: The value of the 'rekey_freq' field MUST be less than 2<span class="super" style="">32</span> and greater than or equal to the value specified by Bob.</p>
      <p class="" style="">Alice MAY also send encrypted content (see the <a href="#exchange">Exchanging Stanzas</a> section of this document) in the same stanza.</p>
      <p class="caption">Example 13. Alice Establishes an ESession Without Negotiation</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com' type='chat'&gt;
  &lt;init xmlns='http://jabber.org/protocol/esession#init'&gt;
    &lt;x xmlns='jabber:x:data'&gt;
      &lt;field var='logging'&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var='modp'&gt;&lt;value&gt;5&lt;/value&gt;&lt;/field&gt;
      &lt;field var='crypt_algs'&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/field&gt;
      &lt;field var='hash_algs'&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/field&gt;
      &lt;field var='compress'&gt;&lt;value&gt;none&lt;/value&gt;&lt;/field&gt;
      &lt;field var='rekey_freq'&gt;&lt;value&gt;1&lt;/value&gt;&lt;/field&gt;
      &lt;field var='stanzas'&gt;&lt;value&gt;message&lt;/value&gt;&lt;/field&gt;
      &lt;field var='secure'&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var='counter'&gt;&lt;value&gt; ** Base64 encoded initial counter value ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var='kid'&gt;&lt;value&gt; ** KID ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var='key'&gt;&lt;value&gt; ** Base64 encoded value of e ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var='pkids'&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='signs'&gt;
        &lt;value&gt; ** Base64 encoded signature of form ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded signature of form ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/init&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
      <p class="" style="">Alice can assume that she and Bob have the same value for K and that the key exchange is complete.</p>
    </div>
    <div class="indent">
<h3>6.2.5 <a name="init-accept">Accepting Offline Esessions</a>
</h3>
      <p class="" style="">When Bob comes online he MUST perform the following steps:</p>
      <ol start="1" type="">
        <li><p class="" style="">Retrieve the two sets of Esession options he MAY have published (see <a href="#init-publish">Publishing Esession Options</a>)</p></li>
        <li>
<p class="" style="">Ensure he is no longer publishing offline Esession options exclusively for entities that are subscribing to his presence</p>
            <p class="caption">Example 14. Bob Stops Publishing His Esession Options</p>
<div class="indent"><pre>
&lt;iq type='set' from='bob@example.com/laptop' id='es4'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession#subscription'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'/&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
        </li>
        <li><p class="" style="">Retrieve any values of y, d and KID that he stored before going offline, and destroy in a secure way any persistently stored copies that correspond to Esession options exclusively for subscribers</p></li>
        <li><p class="" style="">Confirm those values of d and KID match the published values. They may not match if, for example, he went offline using a different client and/or a different machine. Note: if they do not match then he cannot decrypt any offline Esessions he receives.</p></li>
      </ol>
      <p class="" style="">When Bob receives a key exchange stanza from Alice then he MUST perform the following steps:</p>
      <ol start="1" type="">
        <li><p class="" style="">Confirm that the KID he received from Alice matches one of the KIDs he published</p></li>
        <li><p class="" style="">Confirm that he can support all the Esession options he received from Alice</p></li>
        <li><p class="" style="">Confirm that he has not already received a key exchange stanza from Alice with the same value of e since he came online (see <a href="#sec-replay">Replay Attacks</a>)</p></li>
        <li><p class="" style="">Request Alice's public keys and, if possible, verify one of her signatures (see <a href="#sign">Signature Generation</a>; if he is unable to verify any of her signatures then he MAY decide to proceed no further, since he cannot be sure who started the Esession)</p></li>
        <li><p class="" style="">Set the initial value of C<span class="sub" style="">A</span> to the counter value he received from Alice</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> + 2<span class="super" style="">n-1</span> (in case Alice has not yet terminated the Esession)</p></li>
        <li><p class="" style="">Calculate K = e<span class="super" style="">y</span> mod p (the shared secret)</p></li>
      </ol>
    </div>
  </div>

  <div class="indent">
<h3>6.3 <a name="init-keys">Generating Session Keys</a>
</h3>
    <p class="" style="">Whichever method Alice used to perform the Diffie-Hellman key exchange (online or offline), once it is complete, then before Alice and Bob can start encrypting and decrypting stanzas they MUST both use the agreed hash algorithm ("HASH") and their full JIDs to generate two pairs of keys, one for each direction of the ESession. Note: JID<span class="sub" style="">B</span> MUST be Bob's bare JID throughout an offline Esession, even if he comes online in the middle of the Esession and the key is re-exchanged.</p>
    <p class="" style="">For stanzas that Alice will send to Bob, the keys are calculated as:</p>
    <ol start="1" type="">
      <li><p class="" style="">Encryption key K-E<span class="sub" style="">A</span> = HASH(K, JID<span class="sub" style="">A</span>)</p></li>
      <li><p class="" style="">Integrity key K-M<span class="sub" style="">A</span> = HASH(K-E<span class="sub" style="">A</span>, JID<span class="sub" style="">B</span>)  [<a href="#nt-id2258876">28</a>]</p></li>
    </ol>
    <p class="" style="">For stanzas that Bob will send to Alice the keys are calculated as:</p>
    <ol start="4" type="">
      <li><p class="" style="">Encryption key K-E<span class="sub" style="">B</span> = HASH(K, JID<span class="sub" style="">B</span>)</p></li>
      <li><p class="" style="">Integrity key K-M<span class="sub" style="">B</span> = HASH(K-E<span class="sub" style="">B</span>, JID<span class="sub" style="">A</span>)</p></li>
    </ol>
    <p class="" style="">Once the two pairs of keys have been calculated the value of K MUST be securely destroyed.</p>
    <p class="" style="">As many bytes of key data as are needed MUST be taken from the beginning of the hash output. When negotiating a hash, entities MUST ensure that the hash output is no shorter than the required key data. For algorithms with variable-length keys the maximum length (up to the hash output length) SHOULD be used.</p>

    <p class="" style="">With these keys computed and the algorithms agreed upon, ESession initiation is now complete. From this point forward, Alice and Bob MUST exchange only encrypted forms of the one-to-one stanza types they agreed upon (e.g., &lt;message/&gt; and &lt;iq/&gt; stanzas).</p>
  </div>
<h2>7.
       <a name="exchange">Exchanging Stanzas</a>
</h2>
  <div class="indent">
<h3>7.1 <a name="exchange-separate">Encryptable Content</a>
</h3>
    <p class="" style="">Once an Esession has been established, whenever Alice wants to send Bob an encrypted stanza she MUST only encrypt the XML content that would normally be ignored by the intermediate servers. She MUST NOT encrypt stanza wrapper elements or <span style="font-weight: bold">Advanced Message Processing</span> elements.</p>
    <p class="" style="">If this is an offline Esession then Alice SHOULD include a 'Created' SHIM header in the encrypted content. Bob SHOULD trust this header and ignore the unencrypted <span class="ref" style="">Delayed Delivery</span>  [<a href="#nt-id2259075">29</a>] element inserted by his server.</p>

  <p class="caption">Example 15. Unencrypted Stanza</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda'
         to='bob@example.com/laptop'
         type='chat'&gt;
  &lt;body&gt;Hello, Bob!&lt;/body&gt;
  &lt;amp per-hop='true' xmlns='http://jabber.org/protocol/amp'&gt;
    &lt;rule action='error' condition='match-resource' value='exact'/&gt;
  &lt;/amp&gt;
  &lt;headers xmlns='http://jabber.org/protocol/shim'&gt;
    &lt;header name='Created'&gt;2005-02-10T03:01:52Z&lt;/header&gt;
  &lt;/headers&gt;
  &lt;active xmlns='http://jabber.org/protocol/chatstates'/&gt;
&lt;/message&gt;
</pre></div>

  <p class="caption">Example 16. XML Content to be Encrypted</p>
<div class="indent"><pre>
&lt;body&gt;Hello, Bob!&lt;/body&gt;
&lt;headers xmlns='http://jabber.org/protocol/shim'&gt;
  &lt;header name='Created'&gt;2005-02-10T03:01:52Z&lt;/header&gt;
&lt;/headers&gt;
&lt;active xmlns='http://jabber.org/protocol/chatstates'/&gt;
</pre></div>
  </div>
  <div class="indent">
<h3>7.2 <a name="exchange-encrypt">Encryption</a>
</h3>

    <p class="" style="">Alice MUST perform the following steps to encrypt the XML content.</p>
    <ol start="1" type="">
      <li><p class="" style="">Serialize the XML content she wishes to send into an array of UTF-8 bytes, m.  [<a href="#nt-id2259128">30</a>]</p></li>
      <li>
        <p class="" style="">Compress m using the negotiated algorithm. If a compression algorithm other than 'none' was agreed, the compression context is typically initialized after key exchange and passed from one stanza to the next, with only a partial flush at the end of each stanza.  [<a href="#nt-id2259147">31</a>]</p>
        <p class="caption"></p>
<div class="indent"><pre>m_compressed = compress(m)</pre></div>
      </li>
      <li>
        <p class="" style="">Encrypt the data with the agreed algorithm in counter mode, using the encryption key K-E<span class="sub" style="">A</span>. Note: C<span class="sub" style="">A</span> MUST be incremented for each encrypted block or partial block, and if C<span class="sub" style="">A</span>=2<span class="super" style="">n</span>-1 (where n is the number of bits per encryption block for the agreed encryption algorithm) then C<span class="sub" style="">A</span> MUST be "incremented" to 1. Note: if the encryption algorithm 'none' was agreed (see <a href="#sec-unencrypted">Unencrypted Esessions</a>) encryption MUST NOT be performed and C<span class="sub" style="">A</span> MUST be incremented by 1.</p>
        <p class="caption"></p>
<div class="indent"><pre>m_final = encrypt(K-E<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, m_compressed)</pre></div>
      </li>
      <li>
        <p class="" style="">Alice MUST now create the XML <span style="font-style: italic">content</span> of the &lt;encrypted/&gt; XML element (with no CDATA between any of the elements) in canonical form (see <span class="ref" style="">Canonical XML</span>  [<a href="#nt-id2259296">32</a>]). The XML SHOULD include the Base64 encoded value of m_final, and Bob's KID (the one that corresponds to the value of d she used to encrypt the data). It MAY also contain one &lt;key/&gt; element and one or more &lt;old/&gt; elements (see <a href="#rekey">Re-Keying</a>).</p>
        <p class="caption"></p>
<div class="indent"><pre>m_content = '&lt;data kid=" ** KID ** "&gt; ** Base64 encoded m_final ** &lt;/data&gt;'</pre></div>
      </li>
      <li>
        <p class="" style="">The XML content and the value of Alice's encryption block counter C<span class="sub" style="">A</span> <span style="font-style: italic">before</span> the data was encrypted, are now processed through the HMAC algorithm (as defined in Section 2 of <span class="ref" style="">RFC 2104</span>  [<a href="#nt-id2259362">33</a>]), along with the agreed hash algorithm ("HASH") and the integrity key K-M<span class="sub" style="">A</span>.</p>
        <p class="caption"></p>
<div class="indent"><pre>a_mac = HMAC(HASH, K-M<span class="sub" style="">A</span>, m_content, C<span class="sub" style="">A</span>)</pre></div>
      </li>
    </ol>

  </div>
  <div class="indent">
<h3>7.3 <a name="exchange-send">Sending an Encrypted Stanza</a>
</h3>
    <p class="" style="">Before sending the stanza to Bob, Alice MUST wrap m_content and the Base64 encoded value of a_mac (wrapped in a &lt;mac/&gt; element) inside an &lt;encrypted/&gt; element and insert it into the stanza in place of the original content. There MUST NOT be more than one &lt;encrypted/&gt; element per stanza.</p>
    <p class="caption">Example 17. Message Stanza with Encrypted Content</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda'
         to='bob@example.com/laptop'
         type='chat'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
  &lt;amp per-hop='true' xmlns='http://jabber.org/protocol/amp'&gt;
    &lt;rule action='error' condition='match-resource' value='exact'/&gt;
  &lt;/amp&gt;
&lt;/message&gt;
    </pre></div>
  </div>
  <div class="indent">
<h3>7.4 <a name="exchange-decrypt">Decryption</a>
</h3>

    <p class="" style="">When Bob receives the stanza from Alice, he extracts and Base64 decodes the values of m_final and a_mac from the content and performs the following steps. Note: Alice may not have received Bob's last re-key (see <a href="#rekey">Re-Keying</a>) before sending the stanza. So Bob MUST ensure he uses the values of K-E<span class="sub" style="">A</span> and K-M<span class="sub" style="">A</span> that correspond to his KID that Alice specified with the 'kid' attribute of the &lt;data/&gt; element in the stanza he received (and the current value of e that Alice sent him previously).</p>
    <ol start="1" type="">
      <li>
        <p class="" style="">Remove the &lt;mac/&gt; element from the &lt;encrypted/&gt; element and convert the remaining XML <span style="font-style: italic">content</span> into canonical form (with no CDATA between any of the elements, see <span style="font-weight: bold">Canonical XML</span>). Calculate the Message Authentication Code (MAC) for the content.</p>
        <p class="caption"></p>
<div class="indent"><pre>b_mac = HMAC(HASH, K-M<span class="sub" style="">A</span>, m_content, C<span class="sub" style="">A</span>)</pre></div>
      </li>
      <li>
        <p class="" style="">Verify that b_mac and a_mac match. If they are not identical, the content has been tampered with and Bob MUST terminate the ESession by sending an error to Alice.  [<a href="#nt-id2259554">34</a>]</p>
      </li>
      <li>
        <p class="" style="">Decrypt m_final using the agreed algorithm, K-E<span class="sub" style="">A</span> and C<span class="sub" style="">A</span>. Note: C<span class="sub" style="">A</span> MUST be incremented for each decrypted block, and if C<span class="sub" style="">A</span>=2<span class="super" style="">n</span>-1 (where n is the number of bits per encryption block for the agreed encryption algorithm) then C<span class="sub" style="">A</span> MUST be "incremented" to 1. Note: if the encryption algorithm 'none' was agreed decryption MUST NOT be performed and C<span class="sub" style="">A</span> MUST be incremented by 1.</p>
        <p class="caption"></p>
<div class="indent"><pre>m_compressed = decrypt(K-E<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, m_final)</pre></div>
      </li>
      <li>
        <p class="" style="">Decompress m_compressed using the negotiated algorithm (usually 'none').</p>
        <p class="caption"></p>
<div class="indent"><pre>m = decompress(m_compressed)</pre></div>
      </li>
      <li>
        <p class="" style="">Replace the &lt;encrypted/&gt; element in the serialized XML stanza with m and feed the stanza into an XML parser. If the parser returns an XML format error then Bob MUST terminate the ESession by sending an error to Alice.  [<a href="#nt-id2259706">35</a>]</p>
      </li>
    </ol>
  </div>
  <h2>8.
       <a name="rekey">Re-Key Exchange</a>
</h2>
<p class="" style="">Once an attacker has discovered an encryption key it could be used to decrypt all stanzas within a session, including stanzas that were intercepted <span style="font-style: italic">before</span> the key was discovered. To reduce the window of vulnerability, both Alice and Bob SHOULD change their values of x and y and re-exchange the encryption key as regularly as possible. They MUST also destroy all copies of keys as soon as they are no longer needed.</p>
<p class="" style="">Note: Although most entities are capable of re-keying after each stanza, clients running in constrained runtime environments may require a few seconds to re-key. During Esession initiation these clients MAY negotiate the minimum number of stanzas to be exchanged between re-keys at the cost of a larger window of vulnerability. Entities MUST NOT initiate key re-exchanges more frequently than the agreed limit.</p>

  <div class="indent">
<h3>8.1 <a name="rekey-init">Re-Key Initiation</a>
</h3>
    <p class="" style="">Either Alice or Bob MAY initiate a key re-exchange. Here we describe the process initiated by Alice. First she MUST calculate new values for the encryption parameters:</p>
    <ol start="1" type="">
      <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1, where n is the number of bits per encryption block for the agreed encryption algorithm)</p></li>
      <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
      <li><p class="" style="">Generate an opaque unique key identifier (KID) for e</p></li>
      <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (the new shared secret)</p></li>
      <li><p class="" style="">Calculate K-E<span class="sub" style="">A</span>, K-M<span class="sub" style="">A</span>, K-E<span class="sub" style="">B</span>, K-M<span class="sub" style="">B</span> (see <a href="#init-keys">Generating Session Keys</a>)</p></li>
    </ol>
    <p class="" style="">To avoid extra stanzas, the new value of e SHOULD be sent to Bob along with an encrypted stanza. Note: Alice MUST NOT use the new K-E<span class="sub" style="">A</span> and K-M<span class="sub" style="">A</span> to encrypt this stanza or to calculate the MAC. However, she MUST use them when sending subsequent stanzas.</p>
    <p class="" style="">Note: There is no need for Alice to provide a signature because the calculation of the MAC includes the new value of e, see <a href="#exchange">Exchanging Stanzas</a>).</p>
    <p class="caption">Example 18. Alice Sends Re-Key Stanza</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;key kid=' ** KID ** '&gt; ** Base64 encoded value of new e ** &lt;/key&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Note: Bob may not receive the new key before he sends his next stanzas (they may cross in transit). So, before destroying her old values of K-E<span class="sub" style="">B</span> and K-M<span class="sub" style="">B</span>, Alice MUST wait until either she receives a stanza encrypted with the new key, or a reasonable time has passed (60 seconds should cover a network round-trip and calculations by a constrained client). Similarly she MUST wait before destroying her old value of x, in case Bob sends two stanzas before receiving Alice's new key (the first stanza might include a re-key).</p>
  </div>
  <div class="indent">
<h3>8.2 <a name="rekey-accept">Re-Key Acceptance</a>
</h3>
    <p class="" style="">After Bob receives a stanza with a new value of e and he has decrypted the stanza with the old value of K-E<span class="sub" style="">A</span>, he MUST securely destroy all copies of K-E<span class="sub" style="">A</span> and K-E<span class="sub" style="">B</span> and perform the following calculations with the new value of e:</p>
    <ol start="1" type="">
      <li><p class="" style="">Calculate K = e<span class="super" style="">y</span> mod p</p></li>
      <li><p class="" style="">Calculate K-E<span class="sub" style="">A</span>, K-M<span class="sub" style="">A</span>, K-E<span class="sub" style="">B</span>, K-M<span class="sub" style="">B</span> (see <a href="#init-keys">Generating Session Keys</a>)</p></li>
    </ol>
    <p class="" style="">He MUST use these new values to encrypt and decrypt all subsequent stanzas.  [<a href="#nt-id2260131">36</a>]</p>
  </div>
  <div class="indent">
<h3>8.3 <a name="rekey-publish">Publishing Old MAC Values</a>
</h3>
    <p class="" style="">Either entity MAY publish old values of K-M<span class="sub" style="">A</span> and/or K-M<span class="sub" style="">B</span> as part of any encrypted stanza as long as it knows that all the stanzas that MAY use the old values have been received and validated. It MUST wait until it has received either a re-key or a stanza encrypted with a newer key from the other entity.</p>
    <p class="" style="">Once the expired MAC keys have been published, anyone could create valid arbitrary stanzas with them. This prevents anyone being able to prove the authenticity of a transcript of the Esession in the future.</p>
    <p class="caption">Example 19. Publishing Expired MAC Keys</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Entities SHOULD ignore any &lt;old/&gt; elements they receive.</p>
  </div>
  <h2>9.
       <a name="terminate">Esession Termination</a>
</h2>
    <p class="" style="">Either entity MAY terminate an Esession at any time. Before terminating a session Alice MUST calculate the MAC of her encryption block counter C<span class="sub" style="">A</span>, using the agreed hash algorithm ("HASH") and her integrity key K-M<span class="sub" style="">A</span>.</p>
    <p class="caption"></p>
<div class="indent"><pre>a_mac = HMAC(HASH, K-M<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>)</pre></div>
    <p class="" style="">She MUST then securely destroy all keys associated with the Esession and send a termination stanza to Bob.</p>
    <p class="caption">Example 20. Alice Terminates an Esession</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;end xmlns='http://jabber.org/protocol/esession#end'&gt;
      &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/end&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">When Bob receives a termination stanza he MUST verify the MAC and then destroy all keys associated with the Esession.</p>
  <h2>10.
       <a name="sign">Signature Generation</a>
</h2>
    <p class="" style="">Before the signature of a block of XML is calculated, all CDATA between all elements must be removed and the XML MUST be converted to canonical form (see <span style="font-weight: bold">Canonical XML</span>).</p>
  <div class="indent">
<h3>10.1 <a name="sign-canon">Canonical Form (Informative)</a>
</h3>
    <ul>
      <li>Encoded in UTF-8</li>
      <li>Line breaks normalized to ASCII 10</li>
      <li>Attribute values are normalized, as if by a validating processor</li>
      <li>Character references are replaced</li>
      <li>CDATA sections are replaced with their character content</li>
      <li>Empty elements are converted to start-end tag pairs</li>
      <li>All whitespace in character content is retained (excluding characters removed during line feed normalization)</li>
      <li>Normalization of whitespace in start and end tags</li>
      <li>Attribute value delimiters are set to quotation marks (double quotes)</li>
      <li>Special characters in attribute values and character content are replaced by character references (&amp;amp;, &amp;lt;, &amp;gt;, &amp;quot;, &amp;#xD;, &amp;#xA;, &amp;#x9;)</li>
      <li>Lexicographic order is imposed on the namespace declarations (always first) and attributes of each element</li>
    </ul>

  </div>
  <h2>11.
       <a name="sec">Security Considerations</a>
</h2>
  <div class="indent">
<h3>11.1 <a name="sec-prng">Random Numbers</a>
</h3>
    <p class="" style="">Weak pseudo-random number generators (PRNG) enable successful attacks. Implementors MUST use a cryptographically strong PRNG to generate all random numbers (see <span class="ref" style="">RFC 1750</span>  [<a href="#nt-id2260428">37</a>]).</p>
  </div>
  <div class="indent">
<h3>11.2 <a name="sec-rekey">Re-Keying Limits</a>
</h3>
    <p class="" style="">After a key exchange an entity MUST NOT exchange a total of 2<span class="super" style="">32</span> encrypted blocks before it initiates a key re-exchange (see <span class="ref" style="">SSH Transport Layer Encryption Modes</span>  [<a href="#nt-id2260477">38</a>]). Note: This limitation also ensures the same key and counter values are never used to encrypt two different blocks using counter mode (thus preventing simple attacks).</p>
    <p class="" style="">In order to reduce the Perfect Forward Secrecy window of vulnerability, after an extended period of activity, entities SHOULD either re-key or terminate the Esession.</p>
  </div>
  <div class="indent">
<h3>11.3 <a name="sec-keys">Verifying Keys</a>
</h3>
    <p class="" style="">The trust system outlined in this document is based on Alice trusting that the public key presented by Bob is <span style="font-style: italic">actually</span> Bob's key (and vice versa). Determining this trust may be done in a variety of ways depending on the entities' support for different public key (certificate) formats, signing algorithms and signing authorities. For instance, if Bob publishes a PGP/GPG public key, Alice MAY verify that his key is signed by another key that she knows to be good. Or, if Bob provides an X.509 certificate, she MAY check that his key has been signed by a Certificate Authority that she trusts.</p>
    <p class="" style="">When trust cannot be achieved automatically, methods that are not transparent to the users may be employed. For example, Bob could communicate the SHA-256 fingerprint of his public key to Alice via secure out-of-band communication (e.g. face-to-face). This would enable Alice to confirm that the public key she receives in-band is valid. Note however that very few people bother to verify fingerprints in this way. So this method is exceptionally vulnerable to 'man-in-the-middle' attacks. In order to reduce the window of vulnerability, an entity SHOULD remember the fingerprints of all user-validated public keys and alert the user in the future if ever the fingerprint(s) it stored for an entity do not match any of the received public keys.</p>
    <p class="" style="">Alternatively Alice and Bob could agree a shared secret via secure out-of-band communication, Bob could then use it to create an HMAC of his public key that only Alice could verify.</p>
    <p class="" style="">Note: If no keys are acceptable to Alice (because Alice has never verified any of the keys, and because either the keys are not signed, or Alice does not support the signature algorithms of the keys, or she cannot parse the certificate formats, or she does not recognise the authorities that signed the keys) then, although the Esession can still be encrypted, she cannot be sure she is communicating with Bob.</p>
  </div>
  <div class="indent">
<h3>11.4 <a name="sec-replay">Replay Attacks</a>
</h3>
    <p class="" style="">The encryption block counters maintained implicitly by Alice and Bob (C<span class="sub" style="">A</span> and C<span class="sub" style="">B</span>) prevent stanzas being replayed within any Esession. They ensure that the MAC will be different for all stanzas, even if the HMAC key and the content of the stanza are identical.</p>
    <p class="" style="">Alice and Bob MUST ensure that the value of e or d they provide when negotiating each online Esession is unique. This prevents complete online Esessions being replayed.</p>
    <p class="" style="">Since Bob supplies the same value of d for all offline Esessions, to prevent complete offline Esessions being replayed to him, he MUST take care to securely store <span style="font-style: italic">new</span> values (or destroy existing values) of y and KID whenever he goes offline (see <a href="#init-publish">Publishing Esession Options</a>). Also, when Bob next comes online, he MUST remember all the values of e he receives in offline Esession initiation stanzas, and reject any offline Esessions that specify a value of e he has already received (see <a href="#init-accept">Accepting an Offline Esession</a>).</p>
  </div>
  <div class="indent">
<h3>11.5 <a name="sec-unencrypted">Unencrypted Esessions</a>
</h3>
    <p class="" style="">Organisations with full disclosure policies may require entities to disable encryption to enable the logging of all messages on their server. Unencrypted Esessions meet all the <a href="#reqs-sec">Security Requirements</a> except for Confidentiality. This enables Alice to use the 'secure' Esession option to confirm securely with Bob that both client-server connections are secure.</p>
  </div>
  <div class="indent">
<h3>11.6 <a name="sec-storage">Storage</a>
</h3>
    <p class="" style="">If either entity stores a (re-encrypted) transcript of an Esession for future consultation then the Perfect Forward Secrecy offered by this protocol is lost. If the negotiated value of the 'logging' <span style="font-weight: bold">Chat Session Negotiation</span> field is false the entities SHOULD NOT store any part of the Esession content (not even in encrypted form).</p>
  </div>
  <div class="indent">
<h3>11.7 <a name="sec-offline">Offline Esessions</a>
</h3>
    <p class="" style="">Bob MAY decide not to support Offline Esessions since they are significantly less secure than online Esessions. The Perfect Forward Secrecy window of vulnerability is much longer. More seriously, Bob MUST store his private Diffie-Hellman key, y, to local disk or to a server (perhaps symmetrically encrypted with a password). It is <span style="font-style: italic">really</span> hard to securely erase something from a disk. Note: If Bob does not support Offline Esessions then, while he is offline, Alice will probably send him completely unprotected messages!</p>
  </div>
  <div class="indent">
<h3>11.8 <a name="sec-general">Extra Responsabilities of Implementors</a>
</h3>
    <p class="" style="">Cryptography plays only a small part in an entity's security. Even if it implements this protocol perfectly it may still be vulnerable to other attacks. For examples, an implementation might store Esession keys on swap space or save private keys to a file in cleartext! Implementors MUST take very great care when developing applications with secure technologies.</p>
  </div>
  <div class="indent">
<h3>11.9 <a name="sec-mandatory">Mandatory to Implement Technologies</a>
</h3>
    <p class="" style="">An implementation of ESession MUST support the Diffie-Hellman Key Agreement and HMAC algorithms. Note: The parameter names mentioned below are related to secure shell; see <span style="font-weight: bold">SSH Transport Layer Encryption Modes</span> for encryption algorithm details; see the <span class="ref" style="">IANA Secure Shell Protocol Parameters</span>  [<a href="#nt-id2260791">39</a>] for other names.</p>
    <div class="indent">
<h3>11.9.1 <a name="sec-mandatory-encryption">Encryption Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following encryption algorithm:</p>
      <ul>
        <li>aes128-ctr (see <span class="ref" style="">Advanced Encryption Standard</span>  [<a href="#nt-id2260839">40</a>])</li>
      </ul>
      <p class="" style="">The block length of an encryption algorithm's cipher SHOULD be at least 128 bits. An implementation of ESession MAY also support the following encryption algorithms:</p>
      <ul>
        <li>aes256-ctr</li>
        <li>aes192-ctr</li>
        <li>twofish256-ctr (see <span class="ref" style="">Twofish</span>  [<a href="#nt-id2260884">41</a>])</li>
        <li>twofish192-ctr</li>
        <li>twofish128-ctr</li>
        <li>serpent256-ctr (see <span class="ref" style="">Serpent</span>  [<a href="#nt-id2260917">42</a>])</li>
        <li>serpent192-ctr</li>
        <li>serpent128-ctr</li>
        <li>none (no encryption, only signing)</li>
      </ul>
    </div>
    <div class="indent">
<h3>11.9.2 <a name="sec-mandatory-sign">Key Signing Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following signing algorithms:</p>
      <ul>
        <li>rsa (see <span class="ref" style="">RFC 2437</span>  [<a href="#nt-id2260969">43</a>])</li>
        <li>dss (see <span class="ref" style="">Digital Signature Standard</span>  [<a href="#nt-id2260991">44</a>])</li>
      </ul>
    </div>
    <div class="indent">
<h3>11.9.3 <a name="sec-mandatory-public">Public Signature-Verification-Key Formats</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following public key formats:</p>
      <ul>
        <li>ssh-rsa</li>
        <li>ssh-dss</li>
      </ul>
      <p class="" style="">An implementation of ESession SHOULD also support at least the following public key formats:</p>
      <ul>
        <li>x509v3-sign-rsa (see <span class="ref" style="">X.509 Authentication in SSH2</span>  [<a href="#nt-id2261059">45</a>])</li>
        <li>x509v3-sign-dss</li>
        <li>pgp-sign-rsa</li>
        <li>pgp-sign-dss</li>
      </ul>
      <p class="" style="">An implementation of ESession MAY also support the following public key formats:</p>
      <ul>
        <li>spki-sign-rsa</li>
        <li>spki-sign-dss</li>
      </ul>
    </div>
    <div class="indent">
<h3>11.9.4 <a name="sec-mandatory-hash">Hash Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following hash algorithm:</p>
      <ul>
        <li>sha256 (see <span class="ref" style="">Secure Hash Standard</span>  [<a href="#nt-id2261138">46</a>])</li>
      </ul>
      <p class="" style="">An implementation of ESession SHOULD also support at least the following hash algorithm (sha1 and md5 are NOT RECOMMENDED):</p>
      <ul>
        <li>whirlpool (see <span class="ref" style="">Whirlpool</span>  [<a href="#nt-id2261174">47</a>])</li>
      </ul>
    </div>
    <div class="indent">
<h3>11.9.5 <a name="sec-mandatory-compress">Compression Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following compression algorithm:</p>
      <ul>
        <li>none (no compression, the output MUST be the same as the input)</li>
      </ul>
      <p class="" style="">Support for other algorithms is NOT RECOMMENDED since compression partially defeats the <a href="#reqs-repudiate">Repudiability</a> requirement of this JEP by making it more difficult for a third party (with some knowledge of the plaintext) to modify a transcript of an encrypted session in a meaningful way. However, encrypted content is pseudo-random and cannot be compressed, so, in those cases where bandwidth is severely constrained, an implementation of ESession MAY support the following algorithm to compress content before it is encrypted:</p>
      <ul>
        <li>zlib (see <span class="ref" style="">RFC 1950</span>  [<a href="#nt-id2261248">48</a>])</li>
      </ul>
    </div>
  </div>
<h2>12.
       <a name="iana">IANA Considerations</a>
</h2>
  <p class="" style="">This JEP requires no interaction with the <span class="ref" style="">Internet Assigned Numbers Authority (IANA)</span>  [<a href="#nt-id2261326">49</a>]. </p>
<h2>13.
       <a name="registrar">Jabber Registrar Considerations</a>
</h2>
  <div class="indent">
<h3>13.1 <a name="registrar-ns">Namespaces</a>
</h3>
    <p class="" style="">Upon approval of this JEP, the <span class="ref" style="">Jabber Registrar</span>  [<a href="#nt-id2261342">50</a>] shall register the following namespaces:</p>
    <ul>
      <li>http://jabber.org/protocol/esession</li>
      <li>http://jabber.org/protocol/esession#init</li>
      <li>http://jabber.org/protocol/esession#end</li>
      <li>http://jabber.org/protocol/esession#error</li>
    </ul>
  </div>
  <div class="indent">
<h3>13.2 <a name="registrar-formtype">Field Standardization</a>
</h3>
    <p class="" style="">The Jabber Registrar shall reserve the following fields within the scope of Data Forms used for ESession negotation:</p>
    <p class="caption">Registry Submission</p>
<div class="indent"><pre>
&lt;form_type&gt;
  &lt;name&gt;http://jabber.org/protocol/esession&lt;/name&gt;
  &lt;jep&gt;JEP-0116&lt;/jep&gt;
  &lt;desc&gt;ESession negotiation forms&lt;/desc&gt;
  &lt;field
      var='modp'
      type='list-single'
      label='MODP group number'/&gt;
  &lt;field
      var='crypt_algs'
      type='list-single'
      label='Symmetric block cipher options'/&gt;
  &lt;field
      var='hash_algs'
      type='list-single'
      label='Hash algorithm options'/&gt;
  &lt;field
      var='compress'
      type='list-single'
      label='Compression algorithm options'/&gt;
  &lt;field
      var='stanzas'
      type='list-multi'
      label='Stanzas types to encrypt'/&gt;
  &lt;field
      var='secure'
      type='boolean'
      label='Require encrypted client-server streams'/&gt;
  &lt;field
      var='rekey_freq'
      type='text-single'
      label='Minimum number of stanzas between key exchanges'/&gt;
  &lt;field
      var='accept_pkids'
      type='list-multi'
      label='Acceptable public key IDs'/&gt;
  &lt;field
      var='counter'
      type='hidden'
      label='Initial block counter'/&gt;
  &lt;field
      var='kid'
      type='hidden'
      label='Diffie-Hellman key ID'/&gt;
  &lt;field
      var='key'
      type='hidden'
      label='Diffie-Hellman key'/&gt;
  &lt;field
      var='pkey'
      type='hidden'
      label='Public key'/&gt;
  &lt;field
      var='pkids'
      type='list-single'
      label='Public key IDs'/&gt;
  &lt;field
      var='signs'
      type='list-single'
      label='Data form signatures'/&gt;
  &lt;field
      var='req_sign'
      type='hidden'
      label='Signature of initial request data form'/&gt;
&lt;/form_type&gt;
    </pre></div>
  </div>
<h2>14.
       <a name="schema">XML Schemas</a>
</h2>
  <p class="" style="">To follow.</p>
<h2>15.
       <a name="keys">Public Key Publication and Retrieval</a>
</h2>
  <p class="" style=""><span style="font-style: italic">Note: This section is highly preliminary and will be specified in a separate proposal before this document reaches draft status.</span></p>
  <p class="" style="">Entities SHOULD publish their long-term public signature-verification keys to all entities through their own server using the disco#publish-info feature (as <a href="http://mail.jabber.org/pipermail/standards-jig/2005-July/008131.html">NOT SPECIFIED</a> in <span style="font-weight: bold">JEP-0030</span>).</p>

  <p class="caption">Example 21. Entity Publishes Public Keys to Server</p>
<div class="indent"><pre>
&lt;iq type='set' from='alice@example.org/pda' id='dp1'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var='FORM_TYPE'&gt;
        &lt;value&gt;http://jabber.org/protocol/publickeys&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='types'&gt;
        &lt;value&gt;x509v3-sign-rsa&lt;/value&gt;
        &lt;value&gt;pgp-sign-dss&lt;/value&gt;
        &lt;value&gt;ssh-rsa&lt;/value&gt;
        &lt;value&gt;ssh-dss&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='keys'&gt;
        &lt;value&gt; ** Base64 encoded x509 certificate containing RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded OpenPGP certificate containing DSS public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned DSS public key ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>

  <p class="" style="">Before initiating an ESession, if Bob does not already possess one of Alice's signature-verification keys, he SHOULD retrieve them from Alice's server.</p>
  <p class="caption">Example 22. Bob Requests Public Keys from Alice's Server</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='bob@example.com/laptop'
    to='alice@example.org'
    id='dp2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'/&gt;
&lt;/iq&gt;
  </pre></div>

  <p class="caption">Example 23. Server Returns Public Keys</p>
<div class="indent"><pre>
&lt;iq type='result'
    from='alice@example.org'
    to='bob@example.com/laptop'
    id='dp2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'&gt;
    &lt;x type='result' xmlns='jabber:x:data'&gt;
      &lt;field var='FORM_TYPE'&gt;
        &lt;value&gt;http://jabber.org/protocol/publickeys&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='types'&gt;
        &lt;value&gt;x509v3-sign-rsa&lt;/value&gt;
        &lt;value&gt;pgp-sign-dss&lt;/value&gt;
        &lt;value&gt;ssh-rsa&lt;/value&gt;
        &lt;value&gt;ssh-dss&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='keys'&gt;
        &lt;value&gt; ** Base64 encoded x509 certificate containing RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded OpenPGP certificate containing DSS public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned DSS public key ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
  <p class="" style="">Bob should examine all the public keys and identify which ones are acceptable (see <a href="#sec-keys">Verifying Keys</a>).</p>
<h2>16.
       <a name="open">Open Issues</a>
</h2>
  <div class="indent">
<h3>16.1 <a name="open-tothink">To Think About</a>
</h3>
    <ol start="" type="">
      <li>Define an optional protocol that would allow Bob to store y (and the PKIDs he trusts) 'securely' on his own server (before he goes offline). If Bob prefers not to use this protocol (because local storage is more secure), what should he do when he receives an offline Esession if he is <span style="font-style: italic">unable to retrieve the value of y</span> that he stored before going offline (e.g., if he went offline using a different client and/or a different machine)?</li>
      <li>What challenges exist to make the OTR Gaim Plugin use this protocol natively when talking to Jabber entities? Can these be mitigated by 'non-critical' protocol changes?</li>
      <li>Would it be possible for an XMPP entity to exchange encrypted messages and presence with a user of a non-XMPP messaging system, assuming that the gateway both supports this protocol and is compatible with a purpose-built security plugin on the other user's client (e.g. a Gaim plugin connects to the gateway via a non-XMPP network)?</li>
      <li>Could the protocol approximate SSH (or IPsec) more closely without losing the benefits of OTR?</li>
    </ol>
  </div>
  <div class="indent">
<h3>16.2 <a name="open-todo">To Do</a>
</h3>
    <ol start="" type="">
      <li>Perhaps the JEP needs to specify more carefully how block counters are handled between messages, especially in the event of partial blocks?</li>
      <li>Define names for X.509 SubjectPublicKeyInfo public key formats (different to X.509 certificates). This format must be used when keys are distributed within session initiation.</li>
      <li>Discuss signature formats in greater detail.</li>
      <li>Give examples of specific errors and discuss error scenarios throughout document (e.g., what should Bob do if he is not offline and he receives an offline key exchange stanza?).</li>
      <li>Separate public key publishing into another JEP. Should there be a disco item for each key?</li>
      <li>Update Dependencies list</li>
    </ol>
  </div>
<p><hr></p>
<a name="notes"></a><h2>Notes</h2>
<div class="indent">
<p><a name="nt-id2250669">1</a>. JEP-0027: Current Jabber OpenPGP Usage &lt;<a href="http://www.jabber.org/jeps/jep-0027.html">http://www.jabber.org/jeps/jep-0027.html</a>&gt;.</p>
<p><a name="nt-id2250627">2</a>. RFC 3862: Common Presence and Instant Messaging (CPIM): Message Format &lt;<a href="http://www.ietf.org/rfc/rfc3862.txt">http://www.ietf.org/rfc/rfc3862.txt</a>&gt;.</p>
<p><a name="nt-id2250650">3</a>. RFC 3863: Presence Information Data Format (PIDF) &lt;<a href="http://www.ietf.org/rfc/rfc3863.txt">http://www.ietf.org/rfc/rfc3863.txt</a>&gt;.</p>
<p><a name="nt-id2250694">4</a>. RFC 3923: End-to-End Signing and Object Encryption for the Extensible Messaging and Presence Protocol (XMPP) &lt;<a href="http://www.ietf.org/rfc/rfc3923.txt">http://www.ietf.org/rfc/rfc3923.txt</a>&gt;.</p>
<p><a name="nt-id2250454">5</a>. Off-the-Record Communication, or, Why Not to Use PGP &lt;<a href="http://www.isaac.cs.berkeley.edu/~iang/pubs/otr-wpes.pdf">http://www.isaac.cs.berkeley.edu/~iang/pubs/otr-wpes.pdf</a>&gt;.</p>
<p><a name="nt-id2250486">6</a>. RFC 3920: Extensible Messaging and Presence Protocol (XMPP): Core &lt;<a href="http://www.ietf.org/rfc/rfc3920.txt">http://www.ietf.org/rfc/rfc3920.txt</a>&gt;.</p>
<p><a name="nt-id2250514">7</a>. RFC 3921: Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence &lt;<a href="http://www.ietf.org/rfc/rfc3921.txt">http://www.ietf.org/rfc/rfc3921.txt</a>&gt;.</p>
<p><a name="nt-id2255652">8</a>. RFC 2246: The TLS Protocol Version 1.0 &lt;<a href="http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</a>&gt;.</p>
<p><a name="nt-id2255699">9</a>. JEP-0096: File Transfer &lt;<a href="http://www.jabber.org/jeps/jep-0096.html">http://www.jabber.org/jeps/jep-0096.html</a>&gt;.</p>
<p><a name="nt-id2255721">10</a>. JEP-0079: Advanced Message Processing &lt;<a href="http://www.jabber.org/jeps/jep-0079.html">http://www.jabber.org/jeps/jep-0079.html</a>&gt;.</p>
<p><a name="nt-id2255756">11</a>. JEP-0045: Multi-User Chat &lt;<a href="http://www.jabber.org/jeps/jep-0045.html">http://www.jabber.org/jeps/jep-0045.html</a>&gt;.</p>
<p><a name="nt-id2255786">12</a>. JEP-0060: Publish-Subscribe &lt;<a href="http://www.jabber.org/jeps/jep-0060.html">http://www.jabber.org/jeps/jep-0060.html</a>&gt;.</p>
<p><a name="nt-id2255916">13</a>. SSH Protocol Architecture &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-architecture-22.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-architecture-22.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2255889">14</a>. SSH Transport Layer Protocol &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-transport-24.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-transport-24.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2256127">15</a>. The reliable association between an entity and its public keys is beyond the scope of this JEP.</p>
<p><a name="nt-id2256154">16</a>. Naturally, it is possible that Alice or Bob may retain cleartext versions of the exchanged communications; however, that threat is out of scope for this JEP.</p>
<p><a name="nt-id2256373">17</a>. JEP-0030: Service Discovery &lt;<a href="http://www.jabber.org/jeps/jep-0030.html">http://www.jabber.org/jeps/jep-0030.html</a>&gt;.</p>
<p><a name="nt-id2256395">18</a>. JEP-0115: Entity Capabilities &lt;<a href="http://www.jabber.org/jeps/jep-0115.html">http://www.jabber.org/jeps/jep-0115.html</a>&gt;.</p>
<p><a name="nt-id2256494">19</a>. RFC 2631: Diffie-Hellman Key Agreement Method &lt;<a href="http://www.ietf.org/rfc/rfc2631.txt">http://www.ietf.org/rfc/rfc2631.txt</a>&gt;.</p>
<p><a name="nt-id2256559">20</a>. JEP-0155: Chat Session Negotiation &lt;<a href="http://www.jabber.org/jeps/jep-0155.html">http://www.jabber.org/jeps/jep-0155.html</a>&gt;.</p>
<p><a name="nt-id2256625">21</a>. RFC 2409: The Internet Key Exchange (IKE) &lt;<a href="http://www.ietf.org/rfc/rfc2409.txt">http://www.ietf.org/rfc/rfc2409.txt</a>&gt;.</p>
<p><a name="nt-id2256648">22</a>. RFC 3526: More Modular Exponential (MODP) Diffie-Hellman Groups &lt;<a href="http://www.ietf.org/rfc/rfc3526.txt">http://www.ietf.org/rfc/rfc3526.txt</a>&gt;.</p>
<p><a name="nt-id2256756">23</a>. RFC 3548: The Base16, Base32, and Base64 Data Encodings &lt;<a href="http://www.ietf.org/rfc/rfc3548.txt">http://www.ietf.org/rfc/rfc3548.txt</a>&gt;.</p>
<p><a name="nt-id2256913">24</a>. RFC 3766: Determining Strengths For Public Keys Used For Exchanging Symmetric Keys &lt;<a href="http://www.ietf.org/rfc/rfc3766.txt">http://www.ietf.org/rfc/rfc3766.txt</a>&gt;.</p>
<p><a name="nt-id2257220">25</a>. The private signing keys may only be accessible to another of Bob's clients.</p>
<p><a name="nt-id2257228">26</a>. Some servers may not support public key publishing.</p>
<p><a name="nt-id2256934">27</a>. The more often Bob changes his published Esession options, the shorter the Perfect Forward Secrecy window of vulnerability. However, whenever he changes them he divulges his presence to all the entities that are monitoring them.</p>
<p><a name="nt-id2258876">28</a>. K-M<span class="sub" style="">A</span> is a hash of K-E<span class="sub" style="">A</span> (not K) to ensure that if an attacker recovers the decryption key she will not be able to cryptographically convince anyone that it was not her who created the stanza.</p>
<p><a name="nt-id2259075">29</a>. JEP-0091: Delayed Delivery &lt;<a href="http://www.jabber.org/jeps/jep-0091.html">http://www.jabber.org/jeps/jep-0091.html</a>&gt;.</p>
<p><a name="nt-id2259128">30</a>. Although counter mode encryption requires no padding, implementations MAY still disguise the length of m by appending a random number of white-space characters.</p>
<p><a name="nt-id2259147">31</a>. If Bob were to receive a stanza out-of-order, then he would fail to decrypt the stanza and be forced to terminate the Esession.</p>
<p><a name="nt-id2259296">32</a>. Canonical XML 1.0 &lt;<a href="http://www.w3.org/TR/xml-c14n">http://www.w3.org/TR/xml-c14n</a>&gt;.</p>
<p><a name="nt-id2259362">33</a>. RFC 2104: HMAC: Keyed-Hashing for Message Authentication &lt;<a href="http://www.ietf.org/rfc/rfc2104.txt">http://www.ietf.org/rfc/rfc2104.txt</a>&gt;.</p>
<p><a name="nt-id2259554">34</a>. If Bob were to receive a stanza out-of-order, then the MACs would not match because the values of C<span class="sub" style="">A</span> would not be synchronized.</p>
<p><a name="nt-id2259706">35</a>. Bob MUST NOT send a stream error to his server since intermediate entities are not responsible for encoded content.</p>
<p><a name="nt-id2260131">36</a>. If an entity fails to receive any stanza that includes a new key in the correct order, then it will fail to decrypt the next stanza it receives and be forced to terminate the Esession.</p>
<p><a name="nt-id2260428">37</a>. RFC 1750: Randomness Recommendations for Security &lt;<a href="http://www.ietf.org/rfc/rfc1750.txt">http://www.ietf.org/rfc/rfc1750.txt</a>&gt;.</p>
<p><a name="nt-id2260477">38</a>. SSH Transport Layer Encryption Modes &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-04.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-04.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2260791">39</a>. IANA registry of parameters related to secure shell &lt;<a href="http://www.iana.org/assignments/ssh-parameters">http://www.iana.org/assignments/ssh-parameters</a>&gt;.</p>
<p><a name="nt-id2260839">40</a>. Advanced Encryption Standard: Federal Information Processing Standards Publication 197 &lt;<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf</a>&gt;.</p>
<p><a name="nt-id2260884">41</a>. The Twofish Block Cipher &lt;<a href="http://www.schneier.com/twofish.html">http://www.schneier.com/twofish.html</a>&gt;.</p>
<p><a name="nt-id2260917">42</a>. The Serpent Block Cipher &lt;<a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">http://www.cl.cam.ac.uk/~rja14/serpent.html</a>&gt;.</p>
<p><a name="nt-id2260969">43</a>. RFC 2437: PKCS #1: RSA Cryptography Specifications Version 2.0 &lt;<a href="http://www.ietf.org/rfc/rfc2437.txt">http://www.ietf.org/rfc/rfc2437.txt</a>&gt;.</p>
<p><a name="nt-id2260991">44</a>. Digital Signature Standard: Federal Information Processing Standards Publication 186  &lt;<a href="http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf">http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf</a>&gt;.</p>
<p><a name="nt-id2261059">45</a>. X.509 Authentication in SSH2 &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-x509-02.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-x509-02.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2261138">46</a>. Secure Hash Standard: Federal Information Processing Standards Publication 180-2  &lt;<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">http://csrc.nist.gov/publications/fips/fips180-2/fips186-2withchangenotice.pdf</a>&gt;.</p>
<p><a name="nt-id2261174">47</a>. The Whirlpool Hash Function &lt;<a href="http://paginas.terra.com.br/informatica/paulobarreto/WhirlpoolPage.html">http://paginas.terra.com.br/informatica/paulobarreto/WhirlpoolPage.html</a>&gt;.</p>
<p><a name="nt-id2261248">48</a>. RFC 1950: ZLIB Compressed Data Format Specification version 3.3 &lt;<a href="http://www.ietf.org/rfc/rfc1950.txt">http://www.ietf.org/rfc/rfc1950.txt</a>&gt;.</p>
<p><a name="nt-id2261326">49</a>. The Internet Assigned Numbers Authority (IANA) is the central coordinator for the assignment of unique parameter values for Internet protocols, such as port numbers and URI schemes. For further information, see &lt;<a href="http://www.iana.org/">http://www.iana.org/</a>&gt;.</p>
<p><a name="nt-id2261342">50</a>. The Jabber Registrar maintains a list of reserved Jabber protocol namespaces as well as registries of parameters used in the context of protocols approved by the Jabber Software Foundation. For further information, see &lt;<a href="http://www.jabber.org/registrar/">http://www.jabber.org/registrar/</a>&gt;.</p>
</div>
<p><hr></p>
<a name="revs"></a><h2>Revision History</h2>
<div class="indent">
<h4>Version 0.5 (2004-08-10)</h4>
<div class="indent">Added Flexibility requirement; added late signature of initial request; added termination MAC. (ip)
    </div>
<h4>Version 0.4 (2004-08-09)</h4>
<div class="indent">Added (offline) replay protection; required offline Created header; compression is NOT RECOMMENDED; added second set of offline options for subscribers; added JIDs to session key generation; unencrypted sessions; added secure option; sign whole data form; HMAC whole &lt;encrypted/&gt; element; added Esession termination; option to distribute public keys within session initiation; added Integrity requirement; several clarifications (ip)
    </div>
<h4>Version 0.3 (2005-08-02)</h4>
<div class="indent">Restored status to Experimental; complete rewrite; new Introduction, Background, Requirements and Security Considerations; new OTR-inspired protocol; JEP-0155-based negotiation; counter mode encryption; more secure hashes; offline sessions; re-keying; mac publishing; preliminary key and options publishing protocol. (ip/psa)
    </div>
<h4>Version 0.2 (2004-07-26)</h4>
<div class="indent">At the request of the JEP author, changed status to Retracted. (psa)
    </div>
<h4>Version 0.1 (2003-09-09)</h4>
<div class="indent">Initial version. (dss/psa)
    </div>
</div>
<p><hr></p>
<p>END</p>
</body>
</html>
